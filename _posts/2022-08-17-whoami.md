---
layout: post
title: "Who am I?"
date: 2022-08-17 00:00:00 -0000
categories: posts meta
---

My name's Yegor Wienski, but names don't really mean anything, so here's my story.

Back in 2002 mom gave us boys a present--a chinese clone of the Famicom, with keyboard and mouse. That's how my journey started with Basic, and even back then it struck me as quite crude and structureless--no match for more disciplined Algol I've seen in a book.

A year or so after that, my first "real" computer, and a book about C#. I still happen to code in C# for my day job, and before C# 9 I considered C# one of the more well designed mainstream languages out there. Now, though, it's slowly getting too complicated because of feature creep.

Several years passed in experimentation. I've written some assembly to "stay close to the metal". I've written C and C++ (not knowing even which is which) because "C# is just MS' version of that". I tried Delphi and Pascal. I also remember some TCL scripting for a WoW server emulator, and how different TCL was from any other language I tried at the time. Of course, since I played WoW, I tried Lua as well. Toying with the web, I learned some PHP, Perl, JavaScript, CoffeeScript and made a blog with that shimmering stars gif in the background.

Around 2010 I learned about functional programming, and since then my search for new programming languages and paradigms has been relentless. I've tried F#, Haskell, OCaml, Standard ML (which is almost perfect by the way), PureScript. Witnessed the elegance of the lisps. I've learned the old ways of Algol and Fortran. Discovered BLISS, which is a huge inspiration for me, and which is infinitely better than C. I've read some old papers and was puzzled by how some good ideas seemingly did not appear in any real language (probably there were some, I just didn't look for them hard enough). Writing Minecraft mods, I've found that Java is deeply unsatisfactory, Scala is way too overengineered--and Kotlin doesn't really change anything, except even further butchering locality. I've written a fair share of Rust, but it's mostly just fancy Java borrowing some of the control from C++. I've written some Go when it was hot. Automated stuff with Python and Ruby. Tried some TypeScript. Written Objective C and later Swift. I also learned Prolog, Mercury, Futhark, Dart, Nemerle, RED, Nimrod/Nim, and can't really remember what else.

During that time, I started thinking about how I would go about designing my own programming language. Oddly enough, just as I was closing in on a design, Swift was announced, implementing every major point from my design--except, tainted with backwards compatibility with Objective C. However, before I tried writing Swift and learned that, I grew dissatisfied with my old design with every new language I learned. About then I also started reading computer science and math papers on programming languages and calculi. It became apparent to me that programming language designers, including myself, weren't looking into the future far enough. And even into the past! I learned how much insight CS papers from the 70's held, how modern languages were in many ways inferior to Ada, Standard ML, or BLISS.

In this blog I will share with you the ideas I've found deserve to be more widespread.
